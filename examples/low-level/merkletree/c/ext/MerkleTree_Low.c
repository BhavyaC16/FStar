/* This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
 * KreMLin invocation: Kremlin.native -tmpdir ./ext -drop FStar,Prims,LowStar,C,C.*,C.Loops.Spec.Loops,Spec.*,Lib.*,WasmSupport -drop Hacl.Cast,Hacl.UInt8,Hacl.UInt16,Hacl.UInt32,Hacl.UInt64,Hacl.UInt128 -drop Hacl.Spec.Endianness,Hacl.Endianness,Seq.Create -drop Hacl.Impl.SHA2_256.Lemmas,Hacl.Impl.SHA2_384.Lemmas,Hacl.Impl.SHA2_512.Lemmas -drop MerkleTree.High -I ../ ../MerkleTree.Low.fst lib/connect.c lib/Hacl_SHA2_256.c merkle_tree.c
 * F* version: 8f809af7
 * KreMLin version: a6051b52
 */

#include "MerkleTree_Low.h"

void *MerkleTree_Low_root = (void *)(uint8_t)0U;

uint32_t MerkleTree_Low_uint32_pow2(uint32_t sz)
{
  return (uint32_t)1U << sz;
}

bool MerkleTree_Low_uint32_is_pow2(uint32_t n1)
{
  bool b = n1 != (uint32_t)0U && (n1 | n1 - (uint32_t)1U) == (uint32_t)0U;
  return b;
}

uint32_t MerkleTree_Low_uint32_pow2_floor_(uint32_t n1)
{
  if (n1 == (uint32_t)1U)
    return (uint32_t)0U;
  else
    return (uint32_t)1U + MerkleTree_Low_uint32_pow2_floor_(n1 >> (uint32_t)1U);
}

uint32_t MerkleTree_Low_uint32_pow2_floor(uint32_t n1)
{
  return MerkleTree_Low_uint32_pow2_floor_(n1);
}

uint32_t MerkleTree_Low_uint32_num_of_ones(uint32_t n1)
{
  if (n1 == (uint32_t)0U)
    return (uint32_t)0U;
  else
  {
    uint32_t nones = n1 % (uint32_t)2U + MerkleTree_Low_uint32_num_of_ones(n1 / (uint32_t)2U);
    return nones;
  }
}

bool MerkleTree_Low_uu___is_MT(MerkleTree_Low_merkle_tree projectee)
{
  return true;
}

uint32_t MerkleTree_Low___proj__MT__item__nelts(MerkleTree_Low_merkle_tree projectee)
{
  uint32_t nelts = projectee.nelts;
  return nelts;
}

uint32_t MerkleTree_Low___proj__MT__item__nvalues(MerkleTree_Low_merkle_tree projectee)
{
  uint32_t nvalues = projectee.nvalues;
  return nvalues;
}

uint8_t **MerkleTree_Low___proj__MT__item__values(MerkleTree_Low_merkle_tree projectee)
{
  uint8_t **values = projectee.values;
  return values;
}

uint8_t **MerkleTree_Low___proj__MT__item__iroots(MerkleTree_Low_merkle_tree projectee)
{
  uint8_t **iroots = projectee.iroots;
  return iroots;
}

uint8_t **MerkleTree_Low_create_hashes(uint32_t len)
{
  KRML_CHECK_SIZE(sizeof(NULL), len);
  uint8_t **buf = KRML_HOST_MALLOC(sizeof(NULL) * len);
  for (uint32_t _i = 0U; _i < len; ++_i)
    buf[_i] = NULL;
  return buf;
}

void MerkleTree_Low_init_hashes(uint32_t len, uint8_t **hs)
{
  if (!(len == (uint32_t)0U))
  {
    uint8_t *buf = KRML_HOST_CALLOC((uint32_t)32U, sizeof (uint8_t));
    hs[0U] = buf;
    MerkleTree_Low_init_hashes(len - (uint32_t)1U, hs + (uint32_t)1U);
  }
}

void MerkleTree_Low_init_hashes_partial(uint32_t idx, uint32_t len, uint8_t **hs)
{
  MerkleTree_Low_init_hashes(len, hs + idx);
}

MerkleTree_Low_merkle_tree *MerkleTree_Low_create_merkle_tree()
{
  uint8_t **values = NULL;
  uint8_t **iroots = MerkleTree_Low_create_hashes((uint32_t)32U);
  MerkleTree_Low_init_hashes((uint32_t)32U, iroots);
  KRML_CHECK_SIZE(sizeof (MerkleTree_Low_merkle_tree), (uint32_t)1U);
  MerkleTree_Low_merkle_tree *buf = KRML_HOST_MALLOC(sizeof (MerkleTree_Low_merkle_tree));
  buf[0U]
  =
    (
      (MerkleTree_Low_merkle_tree){
        .nelts = (uint32_t)0U,
        .nvalues = (uint32_t)0U,
        .values = values,
        .iroots = iroots
      }
    );
  return buf;
}

uint8_t **MerkleTree_Low_insert_values(uint32_t nelts, uint32_t nvs, uint8_t **vs, uint8_t *e)
{
  if (nelts == nvs)
  {
    uint8_t **ivs = MerkleTree_Low_create_hashes((uint32_t)2U * nelts + (uint32_t)1U);
    memcpy(ivs, vs, nelts * sizeof vs[0U]);
    ivs[nelts] = e;
    KRML_HOST_FREE(vs);
    return ivs;
  }
  else
  {
    vs[nelts] = e;
    return vs;
  }
}

void MerkleTree_Low_copy_hash(uint8_t *src, uint8_t *dst)
{
  memcpy(dst, src, (uint32_t)32U * sizeof src[0U]);
}

void MerkleTree_Low_insert_iroots(uint32_t nelts, uint8_t **irs, uint8_t *nv)
{
  if (nelts == (uint32_t)0U)
    MerkleTree_Low_copy_hash(nv, irs[0U]);
  else
  {
    uint8_t **uu____0 = irs + (uint32_t)1U;
    MerkleTree_Low_insert_iroots(nelts
      - MerkleTree_Low_uint32_pow2(MerkleTree_Low_uint32_pow2_floor(nelts)),
      uu____0,
      nv);
  }
  if (MerkleTree_Low_uint32_is_pow2(nelts + (uint32_t)1U))
    MerkleTree_Low_hash_from_hashes(irs[0U], irs[1U], irs[0U]);
}

void MerkleTree_Low_insert(MerkleTree_Low_merkle_tree *mt, uint8_t *e)
{
  MerkleTree_Low_merkle_tree mtv = mt[0U];
  uint32_t nelts = mtv.nelts;
  uint32_t nelts0 = nelts;
  uint8_t **values = mtv.values;
  uint8_t **values0 = values;
  uint32_t nvalues = mtv.nvalues;
  uint32_t nvalues0 = nvalues;
  uint8_t **iroots = mtv.iroots;
  uint8_t **iroots0 = iroots;
  MerkleTree_Low_insert_iroots(nelts0, iroots0, e);
  uint32_t inelts = nelts0 + (uint32_t)1U;
  uint32_t invalues;
  if (nelts0 == nvalues0)
    invalues = (uint32_t)2U * nelts0 + (uint32_t)1U;
  else
    invalues = nvalues0;
  uint8_t **ivalues = MerkleTree_Low_insert_values(nelts0, nvalues0, values0, e);
  mt[0U] =
    (
      (MerkleTree_Low_merkle_tree){
        .nelts = inelts,
        .nvalues = invalues,
        .values = ivalues,
        .iroots = iroots0
      }
    );
}

void MerkleTree_Low_merkle_root_of_iroots(uint32_t nirs, uint8_t **irs, uint8_t *acc)
{
  if (!(nirs == (uint32_t)0U))
  {
    MerkleTree_Low_merkle_root_of_iroots(nirs - (uint32_t)1U, irs + (uint32_t)1U, acc);
    MerkleTree_Low_hash_from_hashes(irs[0U], acc, acc);
  }
}

void MerkleTree_Low_get_root(MerkleTree_Low_merkle_tree *mt, uint8_t *rt)
{
  MerkleTree_Low_merkle_tree mtv = mt[0U];
  uint32_t nelts = mtv.nelts;
  uint32_t nelts0 = nelts;
  uint8_t **iroots = mtv.iroots;
  uint8_t **irs = iroots;
  uint32_t nirs = MerkleTree_Low_uint32_num_of_ones(nelts0);
  MerkleTree_Low_merkle_root_of_iroots(nirs, irs, rt);
}

void MerkleTree_Low_free_hashes(uint32_t len, uint8_t **hs)
{
  if (!(len == (uint32_t)0U))
  {
    MerkleTree_Low_free_hashes(len - (uint32_t)1U, hs + (uint32_t)1U);
    KRML_HOST_FREE(hs[0U]);
  }
}

void MerkleTree_Low_free_merkle_tree(MerkleTree_Low_merkle_tree *mt)
{
  MerkleTree_Low_merkle_tree mtv = mt[0U];
  uint32_t nelts = mtv.nelts;
  uint32_t nelts0 = nelts;
  uint8_t **values = mtv.values;
  uint8_t **values0 = values;
  uint8_t **values_alloc = values0;
  uint8_t **iroots = mtv.iroots;
  uint8_t **iroots0 = iroots;
  MerkleTree_Low_free_hashes((uint32_t)32U, iroots0);
  KRML_HOST_FREE(iroots0);
  MerkleTree_Low_free_hashes(nelts0, values_alloc);
  KRML_HOST_FREE(values0);
  KRML_HOST_FREE(mt);
}

