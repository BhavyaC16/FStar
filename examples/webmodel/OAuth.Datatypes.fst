(*
  Defines some of the data structures used by the servers participating in the OAuth protocol
*)
module OAuth.Datatypes

open FStar.IO
open Web.Origin
open Web.URI
open Secret.SecString
open Browser.AuxiliaryDatatypes
open Browser.Datatypes
open AuxiliaryFunctions
open Browser.StringFunctions
open Browser.Model.Interface
open Network.Interface

(* The request and response used in the oauth protocol *)
(* Returns a new request if one is created, else an associated response *)
(* {requestResponseValid req resp} should be used *)

type retReqResp = 
| RetRequest : anyRequest -> retReqResp
| RetResponse : actResponse -> retReqResp

val isValidRetResp : anyRequest -> retReqResp -> GTot bool
let isValidRetResp r ret =
  match ret with 
  | RetRequest req -> (match req with 
      | BrowserRequest br -> notForbiddenHeaderfieldInReqHeader (BRequest?.rf br).reqhead 
      | ServerRequest sr -> notForbiddenHeaderfieldInReqHeader (SRequest?.srf sr).sreqhead )
  | RetResponse resp -> (match r with 
      | BrowserRequest br -> requestResponseValid br resp
      | ServerRequest sr -> sRequestResponseValid sr resp)
  
val get_idp_origin: idp_record -> origin
val get_rp_origin: idp_record -> origin
//val read_idps: o:origin -> server (list (ir:idp_record{get_rp_origin ir == o})) 
//val get_idp_record: o:origin -> list idp_record -> option (ir:idp_record{get_idp_origin ir == o})
val read_idp_record: rp:origin -> ip:origin -> server (option (ir:idp_record{get_rp_origin ir == rp /\ get_idp_origin ir == ip}))

val get_idp_auth_endpoint_uri: ir:idp_record -> u:uri{uri_origin u == get_idp_origin ir}
val get_idp_token_endpoint_uri: ir:idp_record -> u:uri{uri_origin u == get_idp_origin ir}
val get_idp_introspection_endpoint_uri: ir:idp_record -> u:uri{uri_origin u == get_idp_origin ir}
val get_client_id: idp_record -> string
val get_client_secret:

type rp_idp_record = {
  rp_origin:origin;
  ip_origin:origin;
  ip_auth_endpoint:uri;
  ip_token_endpoint:uri;
  ip_introspect_endpoint:uri;
  rp_client_id:string;
  rp_client_secret:option secretVal;
  rp_redirect_uri:uri;
}

(* The client_secret for RP generated by IP *)
let clientSecretRPIP = genSecret (SecretVal [rpori;ipori]) (* Generate this using randomString / genSecret *)
let clientIDRPIP = genSecret PublicVal

(* check if the secretVal (secLevel) is indexed by the origin - should not be a public value *)
val checkSecretOrigins : o:torigin -> l:secLevel -> Tot (b:bool)
let checkSecretOrigins o l =
  match l with 
      | PublicVal -> false  (* only allow origin-indexed secrets and no public values *)
      | SecretVal lo -> List.mem o lo

val secretOriginLemma  : o:torigin -> l:secLevel ->
				   Lemma (requires (checkSecretOrigins o l)) (ensures (restricts (l) (SecretVal [o]))) [SMTPat (checkSecretOrigins o l)]
let secretOriginLemma o l = match l with
      | PublicVal -> ()
      | SecretVal lo -> match [o] with | [] -> () | ol -> ()

(* returns true if the origin has a related secretvalue with that origin in its index *)
(* the secretvalue is indexed by both the origin from which the token is generated and the origin to which the token should be sent *)
val indexedOriginTL : list (torigin * secretVal) -> GTot bool
let rec indexedOriginTL tlist = 
  match tlist with 
  | [] -> true
  | (o,v)::tl -> checkSecretOrigins o (Secret?.s v) && indexedOriginTL tl

(* checks for the client_id and client_secret -- as above *)
val indexedOriginCD : list (torigin * secretVal * secretVal) -> GTot bool
let rec indexedOriginCD cdata = 
  match cdata with 
  | [] -> true
  | (o,i,v)::tl -> (Secret?.s i = PublicVal) && checkSecretOrigins o (Secret?.s v) && indexedOriginCD tl 

(* checks for the user and login session and the IdP origin using the session id (origin * session-id * state ) *)
val indexedOriginLS : list (torigin * secretVal * secretVal) -> GTot bool
let rec indexedOriginLS ls = 
  match ls with 
  | [] -> true
  | (o,i,v)::tl -> checkSecretOrigins o (Secret?.s i) && checkSecretOrigins o (Secret?.s v) && indexedOriginLS tl

(* checks for the authorization code list using the state (origin * state * authcode * redirect_uri) -- as above *)
val indexedOriginCL : list (torigin * secretVal * secretVal * uri) -> GTot bool
let rec indexedOriginCL clist = 
  match clist with 
  | [] -> true
  | (o,i,v,u)::tl -> checkSecretOrigins o (Secret?.s i) && checkSecretOrigins o (Secret?.s v) && indexedOriginCL tl

(* s:torigin is the rp/ip that owns the particular list *)
(* associates an origin with client_id and client_secret *)
type clientData' = list (torigin * secretVal * secretVal) (* Store the client id and secret for a given ip/rp *)
type clientData = c:(clientData'){indexedOriginCD c}

val isClientIDPublic : clientData -> GTot bool
let rec isClientIDPublic c = match c with | [] -> true | (o,i,v)::tl -> (Secret?.s i = PublicVal) && isClientIDPublic tl
  
val lemma_clientdata : c:clientData -> Lemma (requires (True)) (ensures (isClientIDPublic c)) 
let rec lemma_clientdata c = match c with | [] -> () | (o,i,v)::tl -> lemma_clientdata tl

(* IP == associates an origin with state and authcode *)
type codeList' = list (rp:torigin * state:secretVal * code:secretVal * red_uri:uri) (* Store the auth code for the rp given the state *)
type codeList = c:(codeList'){indexedOriginCL c}

(* RP == creates a new session id for the user corresponding to the state *)
type loginSession' = list (ip:torigin * sid:secretVal * state:secretVal) (* session id for state value sent to ip *)
type loginSession = l:(loginSession'){indexedOriginLS l}

(* associates an origin with accesstoken *)
type tokenList' = list (torigin * secretVal)
type tokenList = c:(tokenList'){indexedOriginTL c}

(* retrieve the client_id from the client_data table for the given origin-client *)
val getClientID : clientData -> torigin -> Tot (option (s:secretVal{Secret?.s s = PublicVal}))
let rec getClientID cd t = match cd with  
  | [] -> None
  | (o,v,_)::tl -> if o = t then Some v else getClientID tl t

(* retrieve the origin from the client_data table for the given client_id *)
val getCDOrigin : clientData -> secretVal -> Tot torigin
let rec getCDOrigin cd t = match cd with  
  | [] -> blank_origin
  | (o,v,_)::tl -> if v = t then o else getCDOrigin tl t

(* retrieve the client_secret from the client_data table for the given origin *)
val getCDSecret : clientData -> t:torigin -> Tot (option secretVal)
let rec getCDSecret cd t = match cd with  
  | [] -> None
  | (o,v,sv)::tl -> if o = t then Some sv else getCDSecret tl t
		 
(* retrieve the authcode from the codelist for the given origin *)
val getCLRedURI : codeList -> torigin -> Tot (option uri)
let rec getCLRedURI cd t = match cd with  
  | [] -> None 
  | (o,v,sv,u)::tl -> if o = t then Some u else getCLRedURI tl t

(* retrieve the authcode from the codelist for the given origin *)
val getCLCode : codeList -> t:torigin -> Tot (option secretVal)
let rec getCLCode cd t = match cd with  
  | [] -> None 
  | (o,v,sv,u)::tl -> if o = t then Some sv else getCLCode tl t

(* retrieve the IP origin for which the token (state) was generated *)
val getIPLogin : loginSession -> secretVal -> Tot torigin
let rec getIPLogin ls s = match ls with
  | [] -> blank_origin
  | (o,_,t)::tl -> if s = t then o else getIPLogin tl s

(* retrieve the new codelist after using up the authcode for the given origin *)
val getNewCodeList : codeList -> t:torigin -> ac:secretVal -> ru:uri -> Tot (codeList)
let rec getNewCodeList cd t ac ru = match cd with  
  | [] -> []
  | (o,v,sv,u)::tl -> if o = t && sv = ac && ru = u then tl else (o,v,sv,u)::(getNewCodeList  tl t ac ru)

(* retrieve the access token from the list for the origin *)
val getTLToken : tokenList -> t:torigin -> Tot (option (s:secretVal))
let rec getTLToken l t = match l with  
  | [] -> None
  | (o,sv)::tl -> if o = t then Some sv else getTLToken tl t

val cdSecretLemma : l:clientData -> t:torigin -> Lemma (requires (True)) 
		    (ensures (match (getCDSecret l t) with | None -> true | Some sv -> checkSecretOrigins t (Secret?.s sv))) [SMTPat (getCDSecret l t)]
let rec cdSecretLemma l t = match l with 
  | [] -> ()
  | f::tl -> cdSecretLemma tl t

val clCodeLemma : l:codeList -> t:torigin -> Lemma (requires (True)) 
		  (ensures (match (getCLCode l t) with | None -> true | Some sv -> checkSecretOrigins t (Secret?.s sv))) [SMTPat (getCLCode l t)]
let rec clCodeLemma l t = match l with 
  | [] -> ()
  | f::tl -> clCodeLemma tl t

val tlTokenLemma : l:tokenList -> t:torigin -> Lemma (requires (True)) 
		   (ensures (match (getTLToken l t) with | None -> true | Some sv -> checkSecretOrigins t (Secret?.s sv))) [SMTPat (getTLToken l t)]
let rec tlTokenLemma l t = match l with 
  | [] -> ()
  | f::tl -> tlTokenLemma tl t

(* RP == Login session table for rp *)
(* val refLS : loginSession -> FStar.ST.St (ref loginSession) *)
(* let refLS (ls:loginSession) = ST.alloc ls *)

(* (\* IP == client data table for ip *\) *)
(* val refCD : clientData -> St (ref clientData) *)
(* let refCD (cd:clientData) = ST.alloc cd *)

(* (\* IP == auth code list for different rps for ip *\) *)
(* val refCL : codeList -> St (ref codeList) *)
(* let refCL (cl:codeList) = ST.alloc cl *)

(* (\* IP == access-token list for different rps for ip *\) *)
(* val refTL : tokenList -> St (ref tokenList) *)
(* let refTL (tl:tokenList) = ST.alloc tl *)

(* set a CSP policy for the response to allow only scripts from the current source to load *)
let list_dir_value = [DV_Self]
let cspDirD = {dir_name=CSP_default_src;dir_value=list_dir_value}
let cspPol = [cspDirD]

