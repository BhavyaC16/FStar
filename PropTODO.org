* TODO P0 Give squash a definition (workaround no longer working)

- couldn't add a `prop` type annotation on squash (see below), so
  originally assumed squash

<dummy>(0,0-0,0): (Error 72) Identifier not found: [Prims.Tot]
Module Prims resolved into Prims, which does not belong to the list of
modules in scope, namely

- With Guido's new definition of squash this lax checks:
let squash : Type -> prop = fun p -> x:unit{p}
- But still fails non-lax type-checking:
Unexpected error; please file a bug report, ideally with a minimized
version of the source program that triggered the error.
Impossible: Got a computation Prims.Tot with effect args []

- The main problem here seems to be that squash has a non-trivial VC
  and it's too early in the file; just that the last error above
  appears even if I put squash in Type -> Type

- Tried to check only this definition laxly but that only made a
  difference if squash is marked Type -> Type; if it's in Type -> prop
  it still fails with the last error above

- This last problem goes away with --use_two_phase_tc true!

* TODO P1 Update typing rule for refinements to require `prop`
...  after type-checking squash / prims so that we get better errors
and b2p has some chance of kicking in there too ... this is blocker
for porting more examples without lots of pain

- (reverted then reapplied)
  initially triggering b2p to go from bool to Type0 too

- the solution we discussed is to desugar all uses of refinements
  in user code to `t_refine` in prims

- Nik had a first implementation of this that we then had to revert though

* DONE P0 Replace the `logic` qualifier with `prop`
* TODO P0 Get rid of all the newly introduced admits:
** prims.fst (a couple)
** FStar.TSet.fst (one)
** FStar.Algebra.Monoid.fst (8 admits)
- first 5 are post removing logical and stuff
- last 3 are from the original prop changes
- could consider redoing this without pattern-less quantifiers
  (see CommMonoid)
** FStar.List.Tot.Properties.fst (everything related to memP, recursive prop)
- mem_memP
- memP_existsb
- memP_map_intro
- memP_map_elim
- assoc_memP_some
- fold_left_invar
- strict_prefix_of_nil (another recursive prop)
- map_strict_prefix_of
** FStar.Axiomatic.Array
- IndexAppend caused some bogus assertion failed
** FStar.DependentMap (used lax for 2 definitions)
** FStar.Monotonic.Heap.fst (admit in aref_live_at_aref_of)
** FStar.SquashProperties.fst (3 new admits)
Should this actually be moved to examples/paradoxes?
https://coq.inria.fr/library/Coq.Logic.Berardi.html
https://github.com/FStarLang/FStar/issues/360
** FStar.Ref.fst (new admit in write; assertion failed)
* DONE P1 Fix Z3 errors related to reshuffling in prims:
<dummy>(0,0-0,0): (Warning 276) Prims: Unexpected output from Z3:
(error "line 1370 column 4: unknown function/constant Prims.hasEq")
(error "line 1569 column 4: unknown function/constant Prims.hasEq")
(error "line 1741 column 85: unknown function/constant Prims.hasEq")
(error "line 1876 column 4: unknown function/constant Prims.hasEq")
(error "line 1990 column 4: unknown function/constant Prims.hasEq")
(error "line 2350 column 7: named expression already defined")
(error "line 5738 column 7: named expression already defined")
* TODO P1 Carefully review all the uses of Type(0) in the type-checker

There are 20+ hard-coded uses of `Type0` in the type-checker and my
guess is that quite a few of them will have to point at `prop` now.
Plus there are also uses of Type(u) (ktypeu?), where the type-checker
is used to infer that u=0.

[hritcu@resurrected src]$ grep -R ktype0 | grep .fs | grep -v Binary                                               (git)-[c_prop-dev] 
syntax/FStar.Syntax.Util.fs:let ktype0 : term = mk (Tm_type(U_zero)) None dummyRange
syntax/FStar.Syntax.Util.fs:                   as_arg (abs [mk_binder x] body (Some (residual_tot ktype0)))])) None dummyRange
typechecker/FStar.TypeChecker.Util.fs:        else Inl (Rel.new_uvar r vars U.ktype0 |> fst), false
typechecker/FStar.TypeChecker.Util.fs:                let post_k = U.arrow [null_binder res_t] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.Util.fs:                let kwp    = U.arrow [null_binder post_k] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.Util.fs:                then [], U.ktype0, true
typechecker/FStar.TypeChecker.Tc.fs:              let g_opt = Rel.try_teq true env rt U.ktype0 in
typechecker/FStar.TypeChecker.Normalize.fs:                        let ftrue = U.abs bs U.t_true (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.Normalize.fs:                        let ffalse = U.abs bs U.t_false (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.DMFF.fs:    let star_once typ = U.arrow [S.mk_binder <| S.new_bv None typ] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.DMFF.fs:    mk_Total U.ktype0
typechecker/FStar.TypeChecker.DMFF.fs:                mk_Total U.ktype0))
typechecker/FStar.TypeChecker.DMFF.fs:  U.abs [ S.mk_binder p ] body (Some (U.residual_tot U.ktype0))
typechecker/FStar.TypeChecker.DMFF.fs:            (Some (U.residual_tot U.ktype0))
typechecker/FStar.TypeChecker.DMFF.fs:    let t1_star =  U.arrow [S.mk_binder <| S.new_bv None p_type] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.DMFF.fs:      let s_e2 = U.abs x_binders s_e2 (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.DMFF.fs:      U.abs [ S.mk_binder p ] body (Some (U.residual_tot U.ktype0)),
typechecker/FStar.TypeChecker.Rel.fs:        let f' = U.abs bs f (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.Rel.fs:     logical_guard=new_uvar Range.dummyRange scope U.ktype0; //logical guards are always squashed;
typechecker/FStar.TypeChecker.Rel.fs:    logical_guard=new_uvar Range.dummyRange scope U.ktype0; //logical guards are always squashed?
typechecker/FStar.TypeChecker.TcTerm.fs:      | Const_effect -> U.ktype0 //NS: really?
typechecker/FStar.TypeChecker.TcTerm.fs:   | Tm_quoted _ -> U.ktype0
smtencoding/FStar.SMTEncoding.Encode.fs:                | None -> FStar.TypeChecker.Rel.new_uvar Range.dummyRange [] (U.ktype0) |> fst
tests/FStar.Tests.Unif.fs:    else let t, _ = Rel.new_uvar dummyRange [] U.ktype0 in

After a first round of changes in Redmond this looks like this:
[hritcu@resurrected src]$ grep -R ktype0 | grep .fs | grep -v Binary                                               (git)-[c_prop-dev] 
syntax/FStar.Syntax.Util.fs:let ktype0 : term = mk (Tm_type(U_zero)) None dummyRange
syntax/FStar.Syntax.Util.fs:                   as_arg (abs [mk_binder x] body (Some (residual_tot ktype0)))])) None dummyRange
typechecker/FStar.TypeChecker.Util.fs:        else Inl (Rel.new_uvar r vars U.ktype0 |> fst), false
typechecker/FStar.TypeChecker.Util.fs:                let post_k = U.arrow [null_binder res_t] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.Util.fs:                let kwp    = U.arrow [null_binder post_k] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.Util.fs:      let lc = bind e.pos env (Some e) lc (None, U.lcomp_of_comp <| S.mk_Total (if is_prop t then U.kprop else U.ktype0)) in
typechecker/FStar.TypeChecker.Util.fs:                then [], U.ktype0, true
typechecker/FStar.TypeChecker.Tc.fs:              let g_opt = Rel.try_teq true env rt U.ktype0 in
typechecker/FStar.TypeChecker.Rel.fs:        let f' = U.abs bs f (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.Rel.fs:     logical_guard=new_uvar Range.dummyRange scope U.ktype0; //logical guards are always squashed;
typechecker/FStar.TypeChecker.Rel.fs:    logical_guard=new_uvar Range.dummyRange scope U.ktype0; //logical guards are always squashed?
typechecker/FStar.TypeChecker.TcTerm.fs:      | Const_effect -> U.ktype0 //NS: really?
typechecker/FStar.TypeChecker.TcTerm.fs:   | Tm_quoted _ -> U.ktype0
smtencoding/FStar.SMTEncoding.Encode.fs:                | None -> FStar.TypeChecker.Rel.new_uvar Range.dummyRange [] (U.ktype0) |> fst
tests/FStar.Tests.Unif.fs:    else let t, _ = Rel.new_uvar dummyRange [] U.ktype0 in
* TODO P1 Type inference doesn't work so well for prop
** There are many examples but here is one from FStar.Seq.Base.fst,
the prop annotation is currently needed!

abstract type equal (#a:Type) (s1:seq a) (s2:seq a) : prop =
  (length s1 = length s2
   /\ (forall (i:nat{i < length s1}).{:pattern (index s1 i); (index s2 i)} (index s1 i == index s2 i)))

abstract val eq: #a:eqtype -> s1:seq a -> s2:seq a -> Tot (r:bool{r <==> equal s1 s2})

** Same thing in FStar.Seq.Properties.fst:
type permutation (a:eqtype) (s1:seq a) (s2:seq a) =
       (forall i. count i s1 = count i s2)
val lemma_swap_permutes: #a:eqtype -> s:seq a -> i:nat{i<length s} -> j:nat{i <= j && j<length s} -> Lemma
  (permutation a s (swap s i j))
* TODO P1 Refinement of eqtype no longer an eqtype?
** From ulib/FStar.DependentMap.fst (fails with both Type0 and prop):
abstract let restrict
  (#key: eqtype)
  (#value: (key -> Tot Type))
  (p: (key -> Tot prop))
  (m: t key value)
: Tot (t (k: key {p k}) value)
= { mappings = m.mappings }
* TODO P1 Make b2p insertion more resilient to naming
Needed to add extra b2p in FStar.Uint32.fst (and 8, 16, ...):

(* Shift operators *)
abstract
let shift_right (a:t) (s:t) : Pure t
  (requires (b2p (v s < n)))
  (ensures (fun c -> FStar.UInt.shift_right (v a) (v s) = v c))
  = Mk (shift_right (v a) (v s))

abstract
let shift_left (a:t) (s:t) : Pure t
  (requires (b2p (v s < n)))
  (ensures (fun c -> FStar.UInt.shift_left (v a) (v s) = v c))
  = Mk (shift_left (v a) (v s))

This is especially bad in FStar.UInt128.fst

* TODO P1 Bootstrapping works for `... -> Type` but not `... -> prop`
Needed to explicitly add a `... -> Tot prop`
Need more unfolding in maybe_coerce_bool_to_prop,
but not for prop itself

* TODO Minimize prims to end once we've defined GTot
* DONE Some severe performance degradation in FStar.Array.fst
Z3 takes 6GB+ of RAM here!
Verified module: FStar.UInt128 (215850 milliseconds)

Performance degradation also in
- FStar.HyperStack.ST.fst
Verified module: FStar.HyperStack.ST (328484 milliseconds)
- FStar.Buffer.fst
Verified module: FStar.Buffer (3420364 milliseconds)

[hritcu@resurrected ulib]$ /home/hritcu/Projects/fstar/pub/bin/fstar.exe --use_two_phase_tc true --use_extracted_interfaces --use_hints --use_hint_hashes --cache_checked_modules --odir _output FStar.Buffer.fst --z3rlimit_factor 4
FStar.Buffer.fst(0,0-0,0): (Warning 241) Absent cache file FStar.Buffer.fst.checked; will recheck FStar.Buffer.fst and all subsequent files
FStar.Buffer.fst(308,10-308,41): (Error 19) could not prove post-condition
FStar.Buffer.fst(314,10-314,41): (Error 19) could not prove post-condition
FStar.Buffer.fst(320,10-320,41): (Error 19) could not prove post-condition
FStar.Buffer.fst(326,10-326,41): (Error 19) could not prove post-condition
FStar.Buffer.fst(332,10-332,41): (Error 19) could not prove post-condition
FStar.Buffer.fst(338,10-338,41): (Error 19) could not prove post-condition
FStar.Buffer.fst(344,10-344,41): (Error 19) could not prove post-condition
FStar.Buffer.fst(350,10-350,45): (Error 19) could not prove post-condition
FStar.Buffer.fst(356,10-356,50): (Error 19) could not prove post-condition
FStar.Buffer.fst(612,11-612,31): (Error 19) could not prove post-condition
FStar.Buffer.fst(618,11-618,33): (Error 19) could not prove post-condition
FStar.Buffer.fst(624,12-624,35): (Error 19) could not prove post-condition
FStar.Buffer.fst(643,11-643,38): (Error 19) could not prove post-condition
FStar.Buffer.fst(652,11-652,36): (Error 19) could not prove post-condition
FStar.Buffer.fst(674,13-674,22): (Error 19) could not prove post-condition
FStar.Buffer.fst(680,12-680,34): (Error 19) could not prove post-condition
FStar.Buffer.fst(686,12-686,30): (Error 19) could not prove post-condition
FStar.Buffer.fst(696,35-696,54): (Error 19) assertion failed (see also FStar.Buffer.fst(307,19-307,45))
FStar.Buffer.fst(704,12-704,34): (Error 19) could not prove post-condition
FStar.Buffer.fst(718,12-718,34): (Error 19) could not prove post-condition
FStar.Buffer.fst(731,12-731,35): (Error 19) could not prove post-condition
FStar.Buffer.fst(750,12-750,35): (Error 19) could not prove post-condition
FStar.Buffer.fst(762,12-762,37): (Error 19) could not prove post-condition
FStar.Buffer.fst(861,3-864,4): (Error 19) assertion failed(Also see: FStar.HyperStack.ST.fst(75,24-75,36))
FStar.Buffer.fst(1095,8-1095,11): (Error 19) could not prove post-condition (see also FStar.Buffer.fst(1094,6-1094,60))
FStar.Buffer.fst(1096,2-1102,11): (Error 19) assertion failed(Also see: FStar.HyperStack.ST.fst(75,24-75,36))
FStar.Buffer.fst(1147,8-1147,12): (Error 19) could not prove post-condition (see also FStar.Buffer.fst(1140,82-1140,100))
FStar.Buffer.fst(1148,2-1148,24): (Error 19) assertion failed(Also see: FStar.HyperStack.ST.fst(75,24-75,36))
FStar.Buffer.fst(1174,2-1174,24): (Error 19) assertion failed(Also see: FStar.HyperStack.ST.fst(75,24-75,36))
FStar.Buffer.fst(1249,12-1249,35): (Error 19) could not prove post-condition
FStar.Buffer.fst(1293,12-1293,34): (Error 19) could not prove post-condition
Verified module: FStar.Buffer (21260890 milliseconds)
31 errors were reported (see above)

With double encoding only for squash: 46s

With only fix to #1059

F# version with default timeouts:
Verified module: FStar.Buffer (8550198 milliseconds)
175 errors were reported (see above)

OCaml version with 4x timeouts:
... results still pending for more than one hour ...
