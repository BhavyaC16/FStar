* DONE P0 Give squash a definition (workaround now applied)

- couldn't add a `prop` type annotation on squash (see below), so
  originally assumed squash

<dummy>(0,0-0,0): (Error 72) Identifier not found: [Prims.Tot]
Module Prims resolved into Prims, which does not belong to the list of
modules in scope, namely

- With Guido's new definition of squash this lax checks:
let squash : Type -> prop = fun p -> x:unit{p}
- But still fails non-lax type-checking:
Unexpected error; please file a bug report, ideally with a minimized
version of the source program that triggered the error.
Impossible: Got a computation Prims.Tot with effect args []

- The main problem here seems to be that squash has a non-trivial VC
  and it's too early in the file; just that the last error above
  appears even if I put squash in Type -> Type

- Tried to check only this definition laxly but that only made a
  difference if squash is marked Type -> Type; if it's in Type -> prop
  it still fails with the last error above

- This last problem goes away with --use_two_phase_tc true!

* TODO P1 Update typing rule for refinements to require `prop`
...  after type-checking squash / prims so that we get better errors
and b2p has some chance of kicking in there too ... this is blocker
for porting more examples without lots of pain

- (reverted then reapplied)
  initially triggering b2p to go from bool to Type0 too

- the solution we discussed is to desugar all uses of refinements
  in user code to `t_refine` in prims

- Nik had a first implementation of this that we then had to revert though

* DONE P0 Replace the `logic` qualifier with `prop`

* TODO P0 Get rid of all the newly introduced admits:
** FStar.Algebra.Monoid.fst (8 admits)
- first 5 are post removing logical and stuff
- last 3 are from the original prop changes
- could consider redoing this without pattern-less quantifiers
  (see CommMonoid)
** FStar.List.Tot.Properties.fst (everything related to memP, recursive prop)
- mem_memP
- memP_existsb
- memP_map_intro
- memP_map_elim
- assoc_memP_some
- fold_left_invar
- strict_prefix_of_nil (another recursive prop)
- map_strict_prefix_of
** FStar.Axiomatic.Array
- IndexAppend caused some bogus assertion failed
** FStar.DependentMap (used lax for 2 definitions)
** FStar.Monotonic.Heap.fst (admit in aref_live_at_aref_of)
** FStar.SquashProperties.fst (3 new admits)
Should this actually be moved to examples/paradoxes?
https://coq.inria.fr/library/Coq.Logic.Berardi.html
https://github.com/FStarLang/FStar/issues/360
** FStar.Ref.fst (new admit in write; assertion failed)
** FStar.HyperStack.ST
eternal_refs_pred
* TODO P1 Fix Z3 errors related to reshuffling in prims:
<dummy>(0,0-0,0): (Warning 276) Prims: Unexpected output from Z3:
(error "line 1370 column 4: unknown function/constant Prims.hasEq")
(error "line 1569 column 4: unknown function/constant Prims.hasEq")
(error "line 1741 column 85: unknown function/constant Prims.hasEq")
(error "line 1876 column 4: unknown function/constant Prims.hasEq")
(error "line 1990 column 4: unknown function/constant Prims.hasEq")
(error "line 2350 column 7: named expression already defined")
(error "line 5738 column 7: named expression already defined")
* TODO P1 Carefully review all the uses of Type(0) in the type-checker

There are 20+ hard-coded uses of `Type0` in the type-checker and my
guess is that quite a few of them will have to point at `prop` now.
Plus there are also uses of Type(u) (ktypeu?), where the type-checker
is used to infer that u=0.

[hritcu@resurrected src]$ grep -R ktype0 | grep .fs | grep -v Binary                                               (git)-[c_prop-dev] 
syntax/FStar.Syntax.Util.fs:let ktype0 : term = mk (Tm_type(U_zero)) None dummyRange
syntax/FStar.Syntax.Util.fs:                   as_arg (abs [mk_binder x] body (Some (residual_tot ktype0)))])) None dummyRange
typechecker/FStar.TypeChecker.Util.fs:        else Inl (Rel.new_uvar r vars U.ktype0 |> fst), false
typechecker/FStar.TypeChecker.Util.fs:                let post_k = U.arrow [null_binder res_t] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.Util.fs:                let kwp    = U.arrow [null_binder post_k] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.Util.fs:                then [], U.ktype0, true
typechecker/FStar.TypeChecker.Tc.fs:              let g_opt = Rel.try_teq true env rt U.ktype0 in
typechecker/FStar.TypeChecker.Normalize.fs:                        let ftrue = U.abs bs U.t_true (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.Normalize.fs:                        let ffalse = U.abs bs U.t_false (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.DMFF.fs:    let star_once typ = U.arrow [S.mk_binder <| S.new_bv None typ] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.DMFF.fs:    mk_Total U.ktype0
typechecker/FStar.TypeChecker.DMFF.fs:                mk_Total U.ktype0))
typechecker/FStar.TypeChecker.DMFF.fs:  U.abs [ S.mk_binder p ] body (Some (U.residual_tot U.ktype0))
typechecker/FStar.TypeChecker.DMFF.fs:            (Some (U.residual_tot U.ktype0))
typechecker/FStar.TypeChecker.DMFF.fs:    let t1_star =  U.arrow [S.mk_binder <| S.new_bv None p_type] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.DMFF.fs:      let s_e2 = U.abs x_binders s_e2 (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.DMFF.fs:      U.abs [ S.mk_binder p ] body (Some (U.residual_tot U.ktype0)),
typechecker/FStar.TypeChecker.Rel.fs:        let f' = U.abs bs f (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.Rel.fs:     logical_guard=new_uvar Range.dummyRange scope U.ktype0; //logical guards are always squashed;
typechecker/FStar.TypeChecker.Rel.fs:    logical_guard=new_uvar Range.dummyRange scope U.ktype0; //logical guards are always squashed?
typechecker/FStar.TypeChecker.TcTerm.fs:      | Const_effect -> U.ktype0 //NS: really?
typechecker/FStar.TypeChecker.TcTerm.fs:   | Tm_quoted _ -> U.ktype0
smtencoding/FStar.SMTEncoding.Encode.fs:                | None -> FStar.TypeChecker.Rel.new_uvar Range.dummyRange [] (U.ktype0) |> fst
tests/FStar.Tests.Unif.fs:    else let t, _ = Rel.new_uvar dummyRange [] U.ktype0 in

After a first round of changes in Redmond this looks like this:
[hritcu@resurrected src]$ grep -R ktype0 | grep .fs | grep -v Binary                                               (git)-[c_prop-dev] 
syntax/FStar.Syntax.Util.fs:let ktype0 : term = mk (Tm_type(U_zero)) None dummyRange
syntax/FStar.Syntax.Util.fs:                   as_arg (abs [mk_binder x] body (Some (residual_tot ktype0)))])) None dummyRange
typechecker/FStar.TypeChecker.Util.fs:        else Inl (Rel.new_uvar r vars U.ktype0 |> fst), false
typechecker/FStar.TypeChecker.Util.fs:                let post_k = U.arrow [null_binder res_t] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.Util.fs:                let kwp    = U.arrow [null_binder post_k] (S.mk_Total U.ktype0) in
typechecker/FStar.TypeChecker.Util.fs:      let lc = bind e.pos env (Some e) lc (None, U.lcomp_of_comp <| S.mk_Total (if is_prop t then U.kprop else U.ktype0)) in
typechecker/FStar.TypeChecker.Util.fs:                then [], U.ktype0, true
typechecker/FStar.TypeChecker.Tc.fs:              let g_opt = Rel.try_teq true env rt U.ktype0 in
typechecker/FStar.TypeChecker.Rel.fs:        let f' = U.abs bs f (Some (U.residual_tot U.ktype0)) in
typechecker/FStar.TypeChecker.Rel.fs:     logical_guard=new_uvar Range.dummyRange scope U.ktype0; //logical guards are always squashed;
typechecker/FStar.TypeChecker.Rel.fs:    logical_guard=new_uvar Range.dummyRange scope U.ktype0; //logical guards are always squashed?
typechecker/FStar.TypeChecker.TcTerm.fs:      | Const_effect -> U.ktype0 //NS: really?
typechecker/FStar.TypeChecker.TcTerm.fs:   | Tm_quoted _ -> U.ktype0
smtencoding/FStar.SMTEncoding.Encode.fs:                | None -> FStar.TypeChecker.Rel.new_uvar Range.dummyRange [] (U.ktype0) |> fst
tests/FStar.Tests.Unif.fs:    else let t, _ = Rel.new_uvar dummyRange [] U.ktype0 in
* TODO P1 Type inference doesn't work so well for prop
** There are many examples but here is one from FStar.Seq.Base.fst,
the prop annotation is currently needed!

abstract type equal (#a:Type) (s1:seq a) (s2:seq a) : prop =
  (length s1 = length s2
   /\ (forall (i:nat{i < length s1}).{:pattern (index s1 i); (index s2 i)} (index s1 i == index s2 i)))

abstract val eq: #a:eqtype -> s1:seq a -> s2:seq a -> Tot (r:bool{r <==> equal s1 s2})

** Same thing in FStar.Seq.Properties.fst:
type permutation (a:eqtype) (s1:seq a) (s2:seq a) =
       (forall i. count i s1 = count i s2)
val lemma_swap_permutes: #a:eqtype -> s:seq a -> i:nat{i<length s} -> j:nat{i <= j && j<length s} -> Lemma
  (permutation a s (swap s i j))
* TODO P1 Refinement of eqtype no longer an eqtype?
** From ulib/FStar.DependentMap.fst (fails with both Type0 and prop):
abstract let restrict
  (#key: eqtype)
  (#value: (key -> Tot Type))
  (p: (key -> Tot prop))
  (m: t key value)
: Tot (t (k: key {p k}) value)
= { mappings = m.mappings }
* TODO P1 Make b2p insertion more resilient to naming
Needed to add extra b2p in FStar.Uint32.fst (and 8, 16, ...):

(* Shift operators *)
abstract
let shift_right (a:t) (s:t) : Pure t
  (requires (b2p (v s < n)))
  (ensures (fun c -> FStar.UInt.shift_right (v a) (v s) = v c))
  = Mk (shift_right (v a) (v s))

abstract
let shift_left (a:t) (s:t) : Pure t
  (requires (b2p (v s < n)))
  (ensures (fun c -> FStar.UInt.shift_left (v a) (v s) = v c))
  = Mk (shift_left (v a) (v s))

This is especially bad in FStar.UInt128.fst

* TODO P1 Bootstrapping works for `... -> Type` but not `... -> prop`
Needed to explicitly add a `... -> Tot prop`
Need more unfolding in maybe_coerce_bool_to_prop,
but not for prop itself

* TODO Minimize prims to end once we've defined GTot
* TODO Some severe performance degradation in FStar.Array.fst
Z3 takes 6GB+ of RAM here!
Verified module: FStar.UInt128 (215850 milliseconds)

Performance degradation also in
- FStar.HyperStack.ST.fst
