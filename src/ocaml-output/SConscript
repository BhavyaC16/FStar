import sys
import os
import subprocess
import re
import time
import datetime
import tempfile
import SCons

Import('My_env')
env = My_env.Clone()  # ensure changes here don't have impact on other SConscripts

# --------------------------------------------------------------------
conf = Configure(env)
if sys.platform == 'win32' or sys.platform == 'cygwin':  # Windows 32-bit or 64-bit
  menhir = env.WhereIs('menhir', env['ENV']['PATH'], '') # try 'menhir' with no extension
  if menhir == None:
    menhir = env.WhereIs('menhir.exe', env['ENV']['PATH']) # try with .exe
    if menhir == None:
      print ('Failed to find menhir on path ' + env['ENV']['PATH'])
      menhir_tool = None
    else:
      menhir_tool = menhir
  else:
    # Windows Python doesn't know how to handle menhir, which is a PE file with no
    # extension.  Copy it to a temp directory and rename.
    menhir_tool = tempfile.gettempdir() + '\\menhir.exe'
    Execute(Copy(menhir_tool, menhir))
else:
  menhir_tool = conf.CheckProg('menhir') # returns None or the full path to it

menhir_min_version=20161115
if menhir_tool:
  output = subprocess.check_output([menhir_tool, '--version'])
  output = str(output) # on python3, check_output returns bytes, not a string
  srch = re.search(r'.*version ([0-9]*)', output)
  version = int(srch.group(1))
  if version < menhir_min_version:
    raise SCons.Errors.UserError('Correct version of menhir not found (needs a version newer than %d, is %d)'% (menhir_min_version,version))
  env['MENHIR'] = menhir_tool
else:
  raise SCons.Errors.UserError('Cannot find menhir')

# copy environment variable from the OS env block into child process env blocks,
# if the variable exists on the OS side.
def ForwardEnvironmentVariable(env, name):
  value = os.environ.get(name)
  if value:
    env['ENV'][name] = value
    
ForwardEnvironmentVariable(env, 'MENHIRLIB')
ForwardEnvironmentVariable(env, 'OCAMLFIND_CONF')
ForwardEnvironmentVariable(env, 'OCAML_TOPLEVEL_PATH')
ForwardEnvironmentVariable(env, 'CAMLP4LIB')
ForwardEnvironmentVariable(env, 'OCAMLLIB')
env['FSTAR_OCAMLBUILD_EXTRAS'] = '-cflag -g'   # default value, unless overridden in the OS environment
ForwardEnvironmentVariable(env, 'FSTAR_OCAMLBUILD_EXTRAS')

env['MENHIRARGS']='' #'--explain --infer -la 1 --table'
env['OCAMLLEX']='ocamllex'
env['OCAMLBUILD']='ocamlbuild'
env['OCAMLBUILDARGS']='$FSTAR_OCAMLBUILD_EXTRAS -I src/ocaml-output -I src/basic/ml ' \
                      '-I src/parser/ml -I src/fstar/ml -I src/extraction/ml ' \
                      '-I src/prettyprint/ml -I src/tactics/ml -I ulib/ml ' \
                      '-j 24 -build-dir src/ocaml-output/_build -use-ocamlfind'

parse_mly=env.Command('parse.mly', '../parser/parse.mly',
                      ['cd ../..',
                       '$MENHIR $MENHIRARGS --only-preprocess-for-ocamlyacc $SOURCE >$TARGET'])
Depends(parse_mly, menhir_tool)

parse_ml=env.Command(['parse.ml', 'parse.mli'], 'parse.mly', 'ocamlyacc $SOURCE')

# generate FStar.Parser.Parse.fsti from parser/parse.fsi
def generate_fstar_parser_parse_ml(target, source, env):
  parse_mly = str(source[0])
  subprocess.check_output(['ocamlyacc', parse_mly])

  # read the source file into memory
  parse_ml = 'ocaml-output/parse.ml'
  parse_mli= 'ocaml-output/parse.mli'
  try:
    fd = open(parse_ml, 'r')
  except:
    raise SCons.Errors.UserError("Can't read source file %s" % parse_ml)
  sourcefile = fd.read()
  fd.close()

  # delete the temporary files as they are not tracked by SCons and
  # ocamlbuild complains downstream if they are present.
  os.remove(parse_ml)
  os.remove(parse_mli)

  # write the target file
  try:
    fd = open(target[0].get_path(), "w")
  except:
    raise SCons.Errors.UserError("Can't write target file %s" % target[0])

  fd.write('open Prims\n')
  fd.write('open FStar_Errors\n')
  fd.write('open FStar_List\n')
  fd.write('open FStar_Util\n')
  fd.write('open FStar_Range\n')
  fd.write('open FStar_Options\n')
  fd.write('open FStar_Syntax_Syntax\n')
  fd.write('open FStar_Parser_Const\n')
  fd.write('open FStar_Syntax_Util\n')
  fd.write('open FStar_Parser_AST\n')
  fd.write('open FStar_Parser_Util\n')
  fd.write('open FStar_Const\n')
  fd.write('open FStar_Ident\n')
  fd.write('open FStar_String\n')
  fd.write(sourcefile)
  fd.close()

fstar_parser_parse_ml=env.Command('FStar_Parser_Parse.ml', File('parse.mly'), generate_fstar_parser_parse_ml)

# generate FStar_Version.ml from version.txt and other data
def generate_fstar_version_ml(target, source, env):
  # read the source file into memory
  try:
    fd = open(source[0].get_path(), 'r')
  except:
    raise SCons.Errors.UserError("Can't read source file %s" % source[0])
  sourcefile = fd.read().split('\r\n')
  fd.close()
  VERSION = sourcefile[0]

  # the Makefile showed local time along with timezone.  Python27 doesn't support timezones, so report UTC instead
  utcnow = datetime.datetime.utcnow().replace(microsecond=0)
  DATE = utcnow.isoformat()

  if sys.platform == 'win32':
    if os.getenv('PROCESSOR_ARCHITECTURE')=='AMD64':
      PLATFORM='Windows_x64'
    else:
      PLATFORM='Windows_x86'
  else:
    PLATFORM=os.uname()[4]  # machine is at index 4

  COMPILER = 'OCaml ' + str(subprocess.check_output(['ocamlc', '-version'])).split('\r\n')[0]

  # implement tools/get_commit directly
  COMMIT = str(subprocess.check_output(['git', 'log','--pretty=format:%h','-n','1']))
  try:
    subprocess.check_output(['git', 'diff','--exit-code','HEAD'], stderr=subprocess.STDOUT)
  except subprocess.CalledProcessError as e:
    # if we get here, the git diff returned nonzero, indicating a dirty source tree
    COMMIT = COMMIT + ' (dirty)'

  try:
    fd = open(target[0].get_path(), "w")
  except:
    raise SCons.Errors.UserError("Can't write target file %s" % target[0])

  fd.write('open FStar_Util\n')
  fd.write('let dummy () = ();;\n')
  fd.write('FStar_Options._version := "' + VERSION + '";;\n')
  fd.write('FStar_Options._platform := "' + PLATFORM + '";;\n')
  fd.write('FStar_Options._compiler := "' + COMPILER + '";;\n')
  fd.write('FStar_Options._date := "' + DATE + '";;\n')
  fd.write('FStar_Options._commit:= "' + COMMIT + '";;\n')
  fd.close()

fstar_version_ml=env.Command('FStar_Version.ml', '../../version.txt', generate_fstar_version_ml)

readpipe, writepipe = os.pipe()
os.write(writepipe, str.encode('print_endline Sys.ocaml_version'))
os.close(writepipe)
OCAML_VERSION = str(subprocess.check_output(['ocaml','get_branch.ml'], stdin=readpipe)).split('\n')[0]
os.close(readpipe)
env.Command('../extraction/ml/FStar_Extraction_ML_PrintML.ml',
            '../extraction/ml/FStar_Extraction_ML_PrintML_'+OCAML_VERSION+'.ml',
            Copy('$TARGET', '$SOURCE'))

# generate ../parser/boot/parse.fsy from parse.mly
def generate_parse_fsy(target, source, env):
  # read the source file into memory
  try:
    fd = open(source[0].get_path(), 'r')
  except:
    raise SCons.Errors.UserError("Can't read source file %s" % source[0])
  sourcelines = fd.read().split('\n')
  fd.close()

  targetlines = ['%{']
  targetlines.append('#light "off"')
  targetlines.append('// (c) Microsoft Corporation. All rights reserved')
  targetlines.append('open Prims')
  targetlines.append('open FStar')
  targetlines.append('open FStar.Errors')
  targetlines.append('open FStar.List')
  targetlines.append('open FStar.Util')
  targetlines.append('open FStar.Range')
  targetlines.append('open FStar.Options')
  targetlines.append('open FStar.Parser.Const')
  targetlines.append('open FStar.Parser.AST')
  targetlines.append('open FStar.Parser.Util')
  targetlines.append('open FStar.Const')
  targetlines.append('open FStar.Ident')
  targetlines.append('open FStar.String')
  # TODO : fsyacc seems to complain as soon as there is an arrow -> in a %type declaration...
  for s in sourcelines:
    if re.match(r'/%{', s):
      continue
    elif re.match(r'^open ', s):
      continue
    elif re.match(r'%token.*->.*', s):
      continue
    elif re.match(r'%type.*->.*', s):
      continue
    if re.match(r'%token|%type', s):
      s = re.sub(r'[a-zA-Z0-9_]*\.','', s)
    if re.match(r'%token.*->.*', s):
      continue
    if re.match(r'%type.*->.*', s):
      continue
    targetlines.append(s)

  # write the target file
  try:
    fd = open(target[0].get_path(), "wb")
  except:
    raise SCons.Errors.UserError("Can't write target file %s" % target[0])
  for l in targetlines:
    sl = l.split('\n')
    for s in sl:
      fd.write(s)
  fd.close()

fstar_version_ml=env.Command(File('#/../parser/boot/parse.fsy'), File('parse.mly'), generate_parse_fsy)

GENERATED_FILES=['parse.mly','FStar_Parser_Parse.ml','FStar_Version.ml','../extraction/ml/FStar_Extraction_ML_PrintML.ml','../parser/boot/parse.fsy']

main_native = env.Command('_build/src/fstar/ml/main.native', '', 'cd .. && $OCAMLBUILD $OCAMLBUILDARGS main.native')
for g in GENERATED_FILES:
  Depends(main_native, File('#/ocaml-output/'+g))
fstar_exe = env.Command('../../bin/fstar.exe', main_native, Copy('$TARGET', '$SOURCE'))


Return('fstar_exe')

