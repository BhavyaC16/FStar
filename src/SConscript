import sys
import os, os.path
import re
import collections
import subprocess
import traceback
import SCons

Import('My_env')

env = My_env.Clone()  # ensure changes here don't have impact on other SConscripts
ocaml_output = 'ocaml-output/'  # directory to extract Ocaml code to

# launch an external process and return its stdout as a list of lines of text
def docmd(env, cmd):
  try:
    pipe = SCons.Action._subproc(env, cmd,
                                 stdin = 'devnull',
                                 stderr = 'devnull',
                                 stdout = subprocess.PIPE)
  except:
    e = sys.exc_info()[0]
    print ("Error invoking: %s" % cmd)
    print (formatExceptionInfo())
    print ("Exception: %s" % e)
    Exit(1)
  result = []
  line = pipe.stdout.readline()
  while line:
    result.append(line)
    line = pipe.stdout.readline()
  return result

# Scan a .fs file to discover its dependencies, and add .fst/.fsti targets for each.
# Returns a list of File representing the discovered .fs dependencies.
def fs_file_scan(node, env, path):
  # convert from Node to string and fully qualify.  FStar will emit the
  # name in the dependency output as specified on the command line, and
  # we want fully qualified names only in the output.
  fullnode = os.path.abspath(str(node))
  print('Dependency scan: ' + fullnode)
  output = docmd(env, env.subst('$FSTAR $FSTARARGS --dep make') + ' ' + fullnode)
  deps = []
  # output is a list of lines of the form "file: file[ file]*"
  for deplist in output:
    s = deplist.rstrip().split(' ') # trim \r and \n then split by spaces
    target = s[0][:-1] #the 0th string is the target name.  Remove the trailing ':'
    sources = s[1:]    #the remaining strings are the sources.
    deps.append(target)
    deps += sources
  return deps

# register the .fs scanner with SCons
#fs_scan = Scanner(function = fs_file_scan, skeys = ['.fs'])
#env.Append(SCANNERS = fs_scan)

# --------------------------------------------------------------------
# Generate boot files
# --------------------------------------------------------------------

# Return a list, where each element is the concatenation of prefix 'p' with the original element
def addprefix(p, l):
  if isinstance(l, str):
    # l is a space-separated string.  Split into a list of strings.
    l = l.split(' ')
  # else l is a list to begin with
  return [p+x for x in l]

# Scons action, which takes a text source file, and emits a text target file,
# having used the generator function to transform source to target.
def generate_boot_file(target, source, env, generator):
    # read the source file into memory
    try:
        fd = open(source[0].get_path(), 'r')
    except:
        raise SCons.Errors.UserError("Can't read source file %s" % source[0])
    sourcefile = fd.read()
    sourcelines = re.split('\r|\n', sourcefile)
    fd.close()

    # munge the source file into the target file
    targetlines = generator(sourcelines)

    # write the target file
    try:
        fd = open(target[0].get_path(), "w")
    except:
        raise SCons.Errors.UserError("Can't write target file %s" % target[0])
    for l in targetlines:
        fd.write(l)
        fd.write('\n')
    fd.close()

# Scons action, which takes a text source file, and emits a text target file,
# having used the generator function to transform each line of source to target.
def generate_boot_file_ex(target, source, env, generator):
  def LineByLineGenerator(sourcelines):
    targetlines = []
    for s in sourcelines:
      t = generator(s)
      if t != None:
        targetlines.append(t)
    return targetlines
  generate_boot_file(target, source, env, LineByLineGenerator)

# Generate boot/FStar.Tactics.Interpreter.fst from tactics/boot/FStar.Tactics.Interpreter.fs
def generate_TacticsInterpreter(target, source, env):
  def process(s):
    if re.search(r'// *JUST *FSHARP *', s):
      return None
    t = re.sub(r'// *IN F\* *:', '', s)
    return t
  return generate_boot_file_ex(target, source, env, process)

# Generate 'boot/FStar.Parser.Parse.fsti from parser/parser.fsi
def generate_ParserParse(target, source, env):
  def process(sourcelines):
    match = 'module FStar.Parser.Parse'
    replace = 'module FStar.Parser.Parse\nopen FStar.All\nopen FStar.BaseTypes\ntype bytes = array<byte>'
    targetlines = ['#light "off"']
    for i in range(0,len(sourcelines)-13):
      targetlines.append(sourcelines[i].replace(match, replace))
    return targetlines
  return generate_boot_file(target, source, env, process)

# Generate a file by simply copying it
def generate_Copy(target, source, env):
  def process(s):
    return s
  return generate_boot_file_ex(target, source, env, process)

# Generate boot/%.fsti from basic/boot/%.fsi
def generate_Basic(target, source, env):
  def process(s):
    if re.search(r'// *JUST *FSHARP *', s):
      return None
    t = re.sub(r'<.* when .* : equality>', '', s)
    return t
  return generate_boot_file_ex(target, source, env, process)

# Generate boot/%.fsti from prettyprint/boot/%.fsi
def generate_PrettyPrint(target, source, env):
  def process(s):
    if re.search(r'// *JUST *FSHARP *', s):
      return None
    return s
  return generate_boot_file_ex(target, source, env, process)

# all boot files are listed here
ALL_BOOT=addprefix('boot/FStar.',
  ['Util.fsti','List.fsti','Bytes.fsti','String.fsti','BigInt.fsti',
   'Range.fsti','Pprint.fsti','Parser.Parse.fsti',
   'Tactics.Interpreter.fst','Tactics.Interpreter.fsti'])

# Instructions on how to generate all of the ALL_BOOT files
              # tuples of:  (target filename, source filename, and how to generate)
Boot_Rules = [('boot/FStar.Tactics.Interpreter.fst', 'tactics/boot/FStar.Tactics.Interpreter.fs', generate_TacticsInterpreter),
              ('boot/FStar.Parser.Parse.fsti', 'parser/parse.fsi', generate_ParserParse),
              ('boot/FStar.Parser.Parse.fst', 'parser/parser.fs', generate_Copy),
              ('boot/FStar.Tactics.Interpreter.fsti', 'tactics/boot/FStar.Tactics.Interpreter.fsi', generate_Copy),
              ('boot/%.fsti', 'basic/boot/%.fsi', generate_Basic),
              ('boot/%.fsti', 'prettyprint/boot/%.fsi', generate_PrettyPrint),
              ('boot/%.fst', 'basic/boot/%.fs', generate_Copy)
              ]

# Split a pathname into a tuple of (path, basename, extension)
def split_path(p):
  p, n = os.path.split(p)
  root, ext = os.path.splitext(n)
  Parts = collections.namedtuple('Parts', 'path basename extension')
  return Parts(p, root, ext)

# Generate build targets for all files in ALL_BOOT, using the Boot_Rules
boot_target = env.Alias('boot')
for t in ALL_BOOT:
  tparts = split_path(t)
  x = None
  for target, source, action in Boot_Rules:
    if target == t:
        x = env.Command(target, source,  action)
        break
    elif '%' in target:
      # split t into path, basename, and extension
      sourceparts = split_path(source)
      computedsource = sourceparts.path + '/' + tparts.basename + sourceparts.extension
      if os.path.exists(computedsource):
        targetparts = split_path(target)
        computedtarget = targetparts.path + '/' + tparts.basename + targetparts.extension
        x = env.Command(computedtarget, computedsource, action)
        break
  if x == None:
    raise SCons.Errors.UserError('Boot file %s didn\'t match any rule in Boot_Rules'%t)
  env.Alias(boot_target, x)

# --------------------------------------------------------------------
# Extract boot files to .ml
# --------------------------------------------------------------------
if sys.platform == 'win32' or sys.platform == 'cygwin':  # Windows
    fstar_path = '../bin/fstar.exe'
else:  # Unix
    fstar_path = os.path.realpath('../bin/fstar.exe')
    if os.path.exists(fstar):
        filetype = subprocess.check_output(['file',fstar_path])
        if filetype.contains('Mono'):
            env['FSTAR'] = 'mono ' + env['FSTAR']  # F# version, mono fstar.exe
        else:
            env['FSTAR'] = fstar_path                           # OCaml verion, fstar.exe

boot_includes=addprefix('--include ', '../ulib boot basic extraction format fsdoc fstar '+\
                                      'parser prettyprint reflection smtencoding syntax '+\
                                      'tactics tosyntax typechecker')

# This is the way in which we invoke F* for boostrapping
#   -- we use automatic dependence analysis based on files in ulib, src/{basic, ...} and boot
#   -- eager_inference, MLish, lax: all tune type-inference for use with unverified ML programs
env['FSTARARGS'] = '$OTHERFLAGS --expose_interfaces --eager_inference --lax --MLish --no_location_info ' + \
  '--odir ocaml-output --codegen OCaml ' + ' '.join(boot_includes)

ExtractionAction = collections.namedtuple('ExtractionAction', 'source target command')

# Common base for ExtractModule and ExtractNamespace
class ExtractionBase:
  def __init__(self):
    self.commonaction = ''
    self.actions = [];    # list of ExtractionAction tuples
    
# Generate the .ml target filename given an F* source filename
def GetTargetNameFromSourceFile(sourcefile):
  path,filename = os.path.split(sourcefile)
  base,ext = os.path.splitext(filename)
  return base.replace('.','_') + '.ml'

# Helper class for extracting a set of modules
class ExtractModules(ExtractionBase):
  def __init__(self, modulelist):
    ExtractionBase.__init__(self)
    for mtuple in modulelist:
      module, src = mtuple
      action = ExtractionAction(src, ocaml_output+module.replace('.','_') + '.ml', '--extract_module '+module);
      self.actions.append(action)

# Helper class for extracting a set of namespaces
class ExtractNamespace(ExtractionBase):
  def __init__(self, sources, namespace, noextractions=[]):
    ExtractionBase.__init__(self)
    if type(sources)==type(''):
      sources = sources.split(' ')
    if type(noextractions)==type(''):
      noextractions = noextractions.split(' ')
    sources = Flatten(sources)
    argslist = [' --extract_namespace ' + namespace] + [' --no_extract ' + noextract for noextract in noextractions]
    self.commonaction = ' '.join(argslist)
    for file in sources:
      action = ExtractionAction(file, ocaml_output+GetTargetNameFromSourceFile(file), '')
      self.actions.append(action)

# --------------------------------------------------------------------
# The list of all things to extract from the boot files
# Tuples are:  (targetname, ExtractModules|ExtractNamespace)
# --------------------------------------------------------------------
Extractions=[
  ('extract_misc',ExtractModules([
    ('FStar.Pervasives',    'basic/FStar.Common.fs'),
    ('FStar.Common',        'basic/FStar.Common.fs'),
    ('FStar.Range',         'basic/FStar.Range.fs'),
    ('FStar.Ident',         'basic/FStar.Ident.fs'),
    ('FStar.Options',       'basic/FStar.Options.fs'),
    ('FStar.Errors',        'basic/FStar.Errors.fs'),
    ('FStar.Const',         'basic/FStar.Const.fs'),
    ('FStar.Order',         'basic/FStar.Order.fs'),
    ('FStar.Format',        'format/FStar.Format.fs')
  ])),
  ('extract_syntax_basic',ExtractNamespace(
   [addprefix('syntax/FStar.Syntax.','Syntax.fs Unionfind.fs Subst.fs Free.fs InstFV.fs Util.fs Resugar.fs Print.fs Embeddings.fs MutRecTy.fs')],
   'FStar.Syntax')
   ),
  ('extract_fsdoc',ExtractNamespace(
   ['fsdoc/FStar.Fsdoc.Generator.fs'],
   'FStar.Fsdoc')
   ),
   ('extract_parser',ExtractNamespace(
   addprefix('parser/FStar.Parser.','AST.fs Const.fs Driver.fs Dep.fs ToDocument.fs'),
   'FStar.Parser',
   'FStar.Parser.ParseIt') # --no-extract FStar.Parser.ParseIt
   ),
  ('extract_normalizer',ExtractNamespace(
   addprefix('typechecker/FStar.TypeChecker.','Common.fs Env.fs Normalize.fs Err.fs'),
   'FStar.TypeChecker')
   ),
  ('extract_rel',ExtractModules([
   ('FStar.TypeChecker.Rel', 'typechecker/FStar.TypeChecker.Rel.fs')
   ])),
  ('extract_util',ExtractModules([
   ('FStar.TypeChecker.Util', 'typechecker/FStar.TypeChecker.Util.fs')
   ])),
  ('extract_dmff',ExtractModules([
   ('FStar.TypeChecker.DMFF', 'typechecker/FStar.TypeChecker.DMFF.fs')
   ])),
  ('extract_tcterm',ExtractModules([
   ('FStar.TypeChecker.TcTerm', 'typechecker/FStar.TypeChecker.TcTerm.fs')
   ])),
  ('extract_tcinductive',ExtractModules([
   ('FStar.TypeChecker.TcInductive', 'typechecker/FStar.TypeChecker.TcInductive.fs')
   ])),
  ('extract_tc',ExtractModules([
   ('FStar.TypeChecker.Tc', 'typechecker/FStar.TypeChecker.Tc.fs')
   ])),
  ('extract_tosyntax',ExtractNamespace(
   addprefix('tosyntax/FStar.ToSyntax.','Env.fs Interleave.fs ToSyntax.fs'),
   'FStar.ToSyntax')
   ),
  ('extract_extraction',ExtractNamespace(
   addprefix('extraction/FStar.Extraction.','ML.Syntax.fs ML.UEnv.fs ML.Util.fs ML.Code.fs ML.Term.fs ML.Modul.fs Kremlin.fs'),
   'FStar.Extraction')
   ),
  ('extract_tactics',ExtractNamespace(
   [addprefix('tactics/FStar.Tactics.','Types.fs Basic.fs Embedding.fs'), 'boot/FStar.Tactics.Interpreter.fst'],
   'FStar.Tactics',
   'FStar.Tactics.Native')  # --no-extract FStar.Tactics.Native
   ),
  ('extract_reflection',ExtractNamespace(
   addprefix('reflection/FStar.Reflection.','Data.fs Basic.fs Interpreter.fs'),
   'FStar.Reflection',
   'FStar.Reflection.Types')  # --no-extract FStar.Reflection.Types
   ),
  ('extract_smtencoding_base',ExtractNamespace(
   addprefix('smtencoding/FStar.SMTEncoding.','Term.fs Util.fs Z3.fs SplitQueryCases.fs ErrorReporting.fs'),
   'FStar.SMTEncoding')
   ),
  ('extract_encode',ExtractModules([
   ('FStar.SMTEncoding.Encode', 'smtencoding/FStar.SMTEncoding.Encode.fs')
   ])),
  ('extract_solver',ExtractModules([
   ('FStar.SMTEncoding.Solver', 'smtencoding/FStar.SMTEncoding.Solver.fs')
   ])),
  ('extract_fstar',ExtractModules([
   ('FStar.Dependencies',               'fstar/FStar.Dependencies.fs'),
   ('FStar.Universal',                  'fstar/FStar.Universal.fs'),
   ('FStar.Interactive.CompletionTable','fstar/FStar.Interactive.CompletionTable.fs'),
   ('FStar.Interactive.Ide',            'fstar/FStar.Interactive.Ide.fs'),
   ('FStar.Interactive.Legacy',         'fstar/FStar.Interactive.Legacy.fs'),
   ('FStar.Indent',                     'fstar/FStar.Indent.fs'),
   ('FStar.Main',                       'fstar/FStar.Main.fs')
   ]))
]

# List of handy target names that alias sets of targets listed above
ExtractionTargets = [
  ('extract_syntax',     'extract_syntax_basic extract_fsdoc'),
  ('extract_typechecker','extract_rel extract_normalizer extract_util extract_dmff extract_tcterm extract_tcinductive extract_tc'),
  ('extract_smtencoding','extract_encode extract_smtencoding_base extract_solver'),
  ('extract_all',        'extract_tactics extract_smtencoding extract_typechecker extract_reflection extract_misc extract_syntax extract_parser extract_tosyntax extract_extraction extract_fstar')
]

# This class is a wrapper on the Command Action.  It
# overrides CommandAction.process in order to munge the
# command line passed to fstar, to fold in the --extract-module
# arguments.
class FStarBatchAction(SCons.Action.CommandAction):
  def __init__(self, cmd, **kw):
    SCons.Action.CommandAction.__init__(self, cmd, **kw)

  def process(self, target, source, env, executor=None):
    old_cmd_list = self.cmd_list
    if executor:
      lvars = executor.get_lvars()
      changed_targets = lvars['CHANGED_TARGETS'] # get the list of changed target files
      e = env['FSTAR_EXTRACTIONS']
      for c in changed_targets:
        c = str(c).replace('\\', '/')    # For Windows, convert back into '/' based paths
        for action in e.actions:         # Search for this source file in the ExtractionActions
          if action.target == c:
            self.cmd_list += ' ' + action.command # Found:  append the --extract-module command
            break
    # Call the CommandAction's process to do variable substitutions, etc.
    cmd_list, ignore, silent = SCons.Action.CommandAction.process(self, target, source, env, executor)
    # Restore the old self.cmd_list, which is included in the hash of this
    # Action.  Otherwise, differing $CHANGED_TARGETS will trigger rebuilds
    # due to differing hashes.
    self.cmd_list = old_cmd_list
    return cmd_list, ignore, silent

# Generate SCons targets for each Extraction entry
extraction_targets = {}
for name, e in Extractions:
  command = '$FSTAR $FSTARARGS $CHANGED_SOURCES ' + e.commonaction + ' '
  # Set batch_key=None to have Scons launch fstar.exe separately for each .ml file to extract
  fstar_builder = Builder(action=FStarBatchAction(command, batch_key=True, targets='$CHANGED_TARGETS'))
  # Clone the environment for each Extraction, so each can have a different
  # FStarBuilder.  Their command lines all differ.
  batchenv = env.Clone()
  batchenv.Append(BUILDERS={'FStarBuilder':fstar_builder})
  batchenv['FSTAR_EXTRACTIONS'] = e # pass the set of extractions via side-channel, to FStarBatchAction
  for action in e.actions:
    t_cmd = batchenv.FStarBuilder(action.target, action.source)
    Depends(t_cmd, boot_target)     # ensure boot files are built ahead of extraction
    batchenv.Alias(name, t_cmd)     # add this target to the alias

# Turn the ExtractionTargets[] into actual SCons targets
for name, targets in ExtractionTargets:
  for t in targets.split(' '):
    env.Alias(name, t)
extract_target = env.Alias('extract', 'extract_all')


# --------------------------------------------------------------------
# Automatic dependency scanning
# --------------------------------------------------------------------
def formatExceptionInfo(maxTBlevel=5):
   cla, exc, trbk = sys.exc_info()
   excName = cla.__name__
   try:
       excArgs = exc.__dict__["args"]
   except KeyError:
       excArgs = "<no args>"
   excTb = traceback.format_tb(trbk, maxTBlevel)
   return (excName, excArgs, excTb)

# --------------------------------------------------------------------

Return('boot_target', 'extract_target')
